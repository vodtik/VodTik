<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multi Tool Hub — Video Converter</title>
  <style>
    :root{
      --bg:#0b0f12;--panel:#0f1619;--muted:#9aa6ad;--accent:#6ee7b7;--danger:#ff6b6b;--glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#e6eef2;background:linear-gradient(180deg,#071018 0%, #061018 100%);}
    .container{max-width:980px;margin:28px auto;padding:24px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow: 0 6px 30px rgba(2,6,10,0.6);}
    header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
    .logo{width:52px;height:52px;border-radius:12px;background:linear-gradient(135deg,#05282e,#0b5b4c);display:flex;align-items:center;justify-content:center;font-weight:700;color:white}
    h1{font-size:20px;margin:0}
    p.lead{margin:2px 0 0;color:var(--muted);font-size:13px}

    .grid{display:grid;grid-template-columns:1fr 360px;gap:18px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}

    .panel{background:var(--panel);padding:16px;border-radius:12px}
    .controls{display:flex;flex-direction:column;gap:12px}

    label{font-size:13px;color:var(--muted)}
    .file-input{display:flex;gap:12px;align-items:center}
    input[type=file]{display:none}
    .btn{background:var(--glass);border:1px solid rgba(255,255,255,0.03);padding:10px 14px;border-radius:10px;color:var(--accent);cursor:pointer;display:inline-flex;gap:8px;align-items:center}
    .btn.primary{background:linear-gradient(90deg,#0b6b4f22, transparent);color:var(--accent);border:1px solid rgba(110,231,183,0.08)}
    .btn.ghost{background:transparent;color:var(--muted);border:1px dashed rgba(255,255,255,0.03)}

    .select, .input-text{width:100%;padding:10px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:#d9eef2}

    .meta{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:13px}

    .preview{display:flex;flex-direction:column;gap:12px}
    video{width:100%;border-radius:8px;background:#000}

    .progress-wrap{background:rgba(255,255,255,0.03);height:10px;border-radius:999px;overflow:hidden}
    .progress{height:100%;width:0%;background:linear-gradient(90deg,var(--accent), #3ddc9c);}

    .footer{display:flex;justify-content:space-between;align-items:center;margin-top:14px;color:var(--muted);font-size:13px}

    .note{font-size:12px;color:var(--muted);margin-top:8px}
    .error{color:var(--danger);font-weight:600}

    .small{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">MTH</div>
      <div>
        <h1>Video Converter — Multi Tool Hub</h1>
        <p class="lead">Convert videos between popular formats directly in your browser (no backend required).</p>
      </div>
    </header>

    <div class="grid">
      <section class="panel">
        <div class="controls">
          <div>
            <label>Upload video (MP4, MOV, WMV, AVI, MKV, FLV, WEBM)</label>
            <div class="file-input" style="margin-top:8px">
              <label class="btn" id="chooseBtn" for="fileInput">Choose File</label>
              <input id="fileInput" type="file" accept="video/*" />
              <div class="small" id="fileInfo">No file selected</div>
            </div>
            <div class="note">Max recommended file size: <strong>200 MB</strong>. Large files may be slow or fail depending on device memory.</div>
          </div>

          <div>
            <label>Output format</label>
            <select id="formatSelect" class="select" style="margin-top:8px">
              <option value="mp4">MP4</option>
              <option value="mov">MOV</option>
              <option value="wmv">WMV</option>
              <option value="avi">AVI</option>
              <option value="mkv">MKV</option>
              <option value="flv">FLV</option>
              <option value="webm">WEBM</option>
            </select>
          </div>

          <div class="row" style="margin-top:6px">
            <button id="convertBtn" class="btn primary">Convert</button>
            <button id="resetBtn" class="btn ghost">Reset</button>
          </div>

          <div style="margin-top:8px">
            <div class="meta"><div id="status">Idle</div></div>
            <div style="margin-top:8px" class="progress-wrap"><div id="progress" class="progress"></div></div>
            <div id="log" class="note" style="margin-top:8px;white-space:pre-wrap;max-height:120px;overflow:auto"></div>
          </div>

          <div class="note">Technical: this uses <strong>ffmpeg.wasm</strong> in the browser. Some format conversions re-encode video/audio — results and speed depend on your device.</div>
        </div>
      </section>

      <aside class="panel">
        <h3 style="margin:0 0 10px 0">Preview & Download</h3>
        <div class="preview">
          <div>
            <label class="small">Original</label>
            <video id="originalPreview" controls></video>
          </div>

          <div>
            <label class="small">Converted</label>
            <video id="convertedPreview" controls></video>
          </div>

          <div style="display:flex;gap:8px;align-items:center">
            <a id="downloadLink" class="btn" style="display:none" download>Download</a>
            <div id="convertedInfo" class="small" style="color:var(--muted)"></div>
          </div>

        </div>
      </aside>
    </div>

    <div class="footer">
      <div class="small">Made for Multi Tool Hub · Client-side conversion with ffmpeg.wasm</div>
      <div class="small">If conversion fails try a different output or smaller file.</div>
    </div>
  </div>

  <!-- FFmpeg.wasm UMD build -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.8/dist/ffmpeg.min.js"></script>
  <script>
    // Elements
    const fileInput = document.getElementById('fileInput');
    const chooseBtn = document.getElementById('chooseBtn');
    const fileInfo = document.getElementById('fileInfo');
    const formatSelect = document.getElementById('formatSelect');
    const convertBtn = document.getElementById('convertBtn');
    const resetBtn = document.getElementById('resetBtn');
    const progressEl = document.getElementById('progress');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const originalPreview = document.getElementById('originalPreview');
    const convertedPreview = document.getElementById('convertedPreview');
    const downloadLink = document.getElementById('downloadLink');
    const convertedInfo = document.getElementById('convertedInfo');

    let inputFile = null;
    const MAX_MB = 200; // recommended limit

    // FFmpeg setup
    const { createFFmpeg, fetchFile } = FFmpeg;
    const ffmpeg = createFFmpeg({
      log: true,
      corePath: 'https://unpkg.com/@ffmpeg/core@0.11.1/dist/ffmpeg-core.js'
    });

    // Helpers
    function humanFileSize(bytes){
      const thresh = 1024;
      if (Math.abs(bytes) < thresh) return bytes + ' B';
      const units = ['KB','MB','GB','TB'];
      let u = -1;
      do { bytes /= thresh; ++u; } while(Math.abs(bytes) >= thresh && u < units.length-1);
      return bytes.toFixed(1)+' '+units[u];
    }

    function setStatus(text, isError=false){
      statusEl.textContent = text;
      statusEl.style.color = isError ? 'var(--danger)' : 'var(--muted)';
    }

    function appendLog(msg){
      logEl.textContent += msg + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    // File selection
    fileInput.addEventListener('change', (e)=>{
      const f = e.target.files[0];
      clearConverted();
      if(!f) return;
      inputFile = f;
      const ext = f.name.split('.').pop().toLowerCase();
      const supported = ['mp4','mov','wmv','avi','mkv','flv','webm'];
      if(!supported.includes(ext)){
        setStatus('Unsupported file type', true);
        appendLog('Error: Unsupported file type: ' + ext);
        fileInfo.textContent = 'Unsupported file';
        inputFile = null;
        return;
      }
      if(f.size > MAX_MB * 1024 * 1024){
        appendLog('Warning: File is larger than recommended ' + MAX_MB + ' MB');
      }
      fileInfo.textContent = `${f.name} — ${humanFileSize(f.size)}`;
      originalPreview.src = URL.createObjectURL(f);
      originalPreview.load();
      setStatus('Ready to convert');
    });

    // Choose button proxy
    chooseBtn.addEventListener('click', ()=> fileInput.click());

    // Reset
    resetBtn.addEventListener('click', ()=>{
      fileInput.value = null;
      inputFile = null;
      fileInfo.textContent = 'No file selected';
      originalPreview.src = '';
      clearConverted();
      setStatus('Idle');
      logEl.textContent = '';
      progressEl.style.width = '0%';
    });

    function clearConverted(){
      convertedPreview.src = '';
      convertedPreview.load();
      downloadLink.style.display = 'none';
      convertedInfo.textContent = '';
    }

    // Conversion
    convertBtn.addEventListener('click', async ()=>{
      if(!inputFile){ setStatus('Please select a file first', true); return; }
      const outFormat = formatSelect.value;

      // Basic safety: small devices may not handle big conversions
      if(inputFile.size > 600 * 1024 * 1024){ setStatus('File too large for in-browser conversion', true); return; }

      setStatus('Initializing FFmpeg (downloading core) ...');
      appendLog('Loading ffmpeg.wasm core (this runs once)');

      try{
        if(!ffmpeg.isLoaded()){
          await ffmpeg.load();
          appendLog('FFmpeg core loaded');
        } else appendLog('FFmpeg core already loaded');
      }catch(err){
        appendLog('Failed to load FFmpeg core: ' + err.message);
        setStatus('Failed to initialize conversion engine', true);
        return;
      }

      // show progress
      ffmpeg.setProgress(({ratio})=>{
        const percent = Math.min(100, Math.round(ratio*100));
        progressEl.style.width = percent + '%';
        setStatus(`Processing: ${percent}%`);
      });

      ffmpeg.setLogger(({type, message})=>{
        // keep the log concise
        if(message && message.length) appendLog(message);
      });

      const inputExt = inputFile.name.split('.').pop().toLowerCase();
      const outName = 'output.' + outFormat;
      const inputName = 'input.' + inputExt;

      try{
        setStatus('Writing file to virtual FS...');
        appendLog('Writing input file...');
        ffmpeg.FS('writeFile', inputName, await fetchFile(inputFile));

        // Build a conservative command per output - some formats require re-encoding
        // We pick widely compatible codecs where possible.
        let args = ['-i', inputName];

        // For webm -> use vp8/opus
        if(outFormat === 'webm') args.push('-c:v','libvpx','-b:v','1M','-c:a','libvorbis', outName);
        else if(outFormat === 'mp4') args.push('-c:v','libx264','-preset','veryfast','-crf','23','-c:a','aac', outName);
        else if(outFormat === 'mov') args.push('-c:v','libx264','-c:a','aac', outName);
        else if(outFormat === 'wmv') args.push('-c:v','wmv2','-c:a','mp3', outName);
        else if(outFormat === 'avi') args.push('-c:v','mpeg4','-qscale:v','5','-c:a','mp3', outName);
        else if(outFormat === 'mkv') args.push('-c:v','libx264','-c:a','aac', outName);
        else if(outFormat === 'flv') args.push('-c:v','flv','-c:a','mp3', outName);
        else args.push(outName);

        appendLog('Running ffmpeg: ' + args.join(' '));
        setStatus('Converting — this may take a while');

        await ffmpeg.run(...args);

        appendLog('Conversion finished — reading output');
        const data = ffmpeg.FS('readFile', outName);
        const blob = new Blob([data.buffer], { type: 'video/' + (outFormat === 'mp4' ? 'mp4' : outFormat) });
        const url = URL.createObjectURL(blob);

        convertedPreview.src = url;
        convertedPreview.load();
        convertedInfo.textContent = `${outName} — ${humanFileSize(blob.size)}`;

        downloadLink.href = url;
        downloadLink.download = inputFile.name.replace(/\.[^/.]+$/, '') + '.' + outFormat;
        downloadLink.style.display = 'inline-flex';
        downloadLink.textContent = 'Download ' + outFormat.toUpperCase();

        setStatus('Conversion complete');
        progressEl.style.width = '100%';
      }catch(err){
        appendLog('Conversion error: ' + (err.message || err));
        setStatus('Conversion failed', true);
      }finally{
        // attempt to clean FS
        try{ ffmpeg.FS('unlink', inputName); }catch(e){}
        try{ ffmpeg.FS('unlink', 'output.' + outFormat); }catch(e){}
      }
    });

    // Small UX improvement: drag & drop
    const container = document.querySelector('.container');
    ['dragenter','dragover'].forEach(ev=> container.addEventListener(ev, e=>{ e.preventDefault(); container.style.outline = '2px dashed rgba(110,231,183,0.08)'; }));
    ['dragleave','drop'].forEach(ev=> container.addEventListener(ev, e=>{ container.style.outline=''; }));
    container.addEventListener('drop', (e)=>{
      e.preventDefault();
      const f = e.dataTransfer.files[0];
      if(f){
        fileInput.files = e.dataTransfer.files; // trigger change
        fileInput.dispatchEvent(new Event('change'));
      }
    });

  </script>
</body>
</html>
